<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Order Resolver</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23000'%3E%3Cpath d='M12 2C8 2 4 2.5 4 6v9.5c0 1.93 1.57 3.5 3.5 3.5L6 20.5v.5h2l2-2h4l2 2h2v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-4-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm2 0V6h5v5h-5zm3.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: #fff;
            color: #000;
            padding: 20px;
            padding-top: 40px;
            transition: justify-content 0.3s ease;
        }
        body.centered {
            justify-content: center;
            padding-top: 20px;
        }
        .container {
            width: 100%;
            max-width: 900px;
            text-align: center;
        }
        h1 {
            font-size: 1.2rem;
            font-weight: normal;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        /* Search form */
        .search-form {
            width: 100%;
            margin-bottom: 20px;
        }
        .input-wrapper {
            position: relative;
            width: 100%;
        }
        input[type="text"] {
            width: 100%;
            padding: 15px 40px 15px 45px;
            font-family: inherit;
            font-size: 1.1rem;
            border: 1px solid #000;
            outline: none;
            text-align: center;
        }
        input[type="text"]:focus {
            border-width: 1px;
        }
        input[type="text"]::placeholder {
            color: #999;
        }
        .clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #999;
            cursor: pointer;
            padding: 5px 10px;
            display: none;
        }
        .clear-btn:hover {
            color: #000;
        }
        .input-wrapper.has-value .clear-btn {
            display: block;
        }

        /* Microphone button */
        .mic-btn {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: color 0.2s ease;
        }
        .mic-btn:hover {
            color: #000;
        }
        .mic-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .mic-icon {
            fill: currentColor;
        }
        .mic-btn.recording {
            color: #dc3545;
        }
        .mic-btn.recording .mic-icon {
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
        .mic-btn.recording::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid #dc3545;
            border-radius: 50%;
            animation: ring-pulse 1.5s ease-out infinite;
        }
        @keyframes ring-pulse {
            0% { transform: scale(0.8); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .mic-btn.loading {
            color: #666;
        }
        .mic-btn.loading .mic-icon {
            animation: pulse 1.5s ease-in-out infinite;
        }
        .mic-btn.transcribing {
            color: #2196f3;
        }
        .mic-btn.transcribing .mic-icon {
            display: none;
        }
        .mic-btn .transcribing-icon {
            display: none;
        }
        .mic-btn.transcribing .transcribing-icon {
            display: block;
            fill: currentColor;
            animation: transcribe-pulse 1.2s ease-in-out infinite;
        }
        @keyframes transcribe-pulse {
            0%, 100% { opacity: 0.4; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        /* Wave animation for recording */
        .wave-container {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 24px;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .wave-container.visible {
            display: flex;
        }
        .wave-bar {
            width: 4px;
            height: 8px;
            background: #000;
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }
        /* Hide mic button during recording */
        .input-wrapper.recording .mic-btn {
            opacity: 0;
            pointer-events: none;
        }
        .wave-bar:nth-child(1) { animation-delay: 0s; }
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        .wave-bar:nth-child(6) { animation-delay: 0.3s; }
        .wave-bar:nth-child(7) { animation-delay: 0.2s; }
        .wave-bar:nth-child(8) { animation-delay: 0.1s; }
        .wave-bar:nth-child(9) { animation-delay: 0s; }
        @keyframes wave {
            0%, 100% { height: 8px; opacity: 0.5; }
            50% { height: 24px; opacity: 1; }
        }
        .input-wrapper.recording input {
            color: transparent;
        }
        .input-wrapper.recording input::placeholder {
            color: transparent;
        }
        /* Hide cursor during transcription */
        .input-wrapper.transcribing input {
            caret-color: transparent;
        }

        /* Smooth transition for main content */
        .search-form,
        .tabs-container {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* Hide main content during initial loading */
        body.model-loading .search-form,
        body.model-loading .tabs-container {
            opacity: 0;
            visibility: hidden;
        }

        /* Voice loading indicator - centered during initial load */
        .voice-loading {
            position: fixed;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            border: 1px solid #000;
            padding: 20px 35px;
            z-index: 1000;
            text-align: center;
            min-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, top 0.3s ease;
            top: 50%;
        }
        .voice-loading.visible {
            opacity: 1;
            visibility: visible;
        }
        .voice-loading-text {
            font-size: 0.85rem;
            margin-bottom: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .voice-loading-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            overflow: hidden;
        }
        .voice-loading-fill {
            height: 100%;
            background: #000;
            width: 0%;
            transition: width 0.3s ease;
        }
        .voice-loading-percent {
            font-size: 0.75rem;
            color: #666;
            margin-top: 5px;
        }

        /* Sliding Tabs */
        .tabs-container {
            margin: 25px 0;
            display: flex;
            justify-content: center;
        }
        .tabs {
            display: inline-flex;
            background: #f0f0f0;
            border-radius: 30px;
            padding: 4px;
            position: relative;
        }
        .tab {
            padding: 10px 24px;
            font-family: inherit;
            font-size: 0.85rem;
            background: transparent;
            border: none;
            cursor: pointer;
            position: relative;
            z-index: 1;
            transition: color 0.3s ease;
            white-space: nowrap;
        }
        .tab:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .tab.active {
            color: #fff;
        }
        .tab:not(.active):not(:disabled):hover {
            color: #333;
        }
        .tab-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            background: #000;
            border-radius: 26px;
            transition: left 0.3s ease, width 0.3s ease;
            z-index: 0;
        }
        .model-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            vertical-align: middle;
        }
        .model-badge.unavailable {
            background: #ffebee;
            color: #c62828;
        }

        /* Loading indicator */
        .loading {
            display: none;
            margin: 20px 0;
            font-size: 0.9rem;
            color: #666;
        }
        .loading.visible {
            display: block;
        }
        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Results container */
        .results-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .results-container.single {
            justify-content: center;
        }
        .results-container.compare {
            justify-content: space-between;
        }
        .result-column {
            flex: 1;
            max-width: 100%;
        }
        .results-container.compare .result-column {
            max-width: calc(50% - 10px);
        }
        .model-title {
            font-size: 0.9rem;
            letter-spacing: 1px;
            color: #000;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #000;
        }

        /* Detection panel */
        .detection-panel {
            padding: 15px;
            background: transparent;
            border: 1px solid #000;
            text-align: left;
            margin-bottom: 15px;
        }
        .detection-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
        }
        .highlighted-sentence {
            font-size: 0.95rem;
            line-height: 1.6;
            padding: 10px;
            background: #fff;
            border: 1px dashed #ccc;
            margin-bottom: 15px;
            word-break: break-word;
        }
        .highlight-departure {
            background: #d4edda;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px solid #28a745;
        }
        .highlight-arrival {
            background: #f8d7da;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px solid #dc3545;
        }
        .detection-details {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .detection-item {
            flex: 1;
            min-width: 150px;
            padding: 10px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        .detection-item.departure {
            border-left: 3px solid #28a745;
        }
        .detection-item.arrival {
            border-left: 3px solid #dc3545;
        }
        .detection-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 5px;
        }
        .detection-value {
            font-size: 0.95rem;
            font-weight: bold;
        }
        .detection-meta {
            font-size: 0.7rem;
            color: #888;
            margin-top: 5px;
        }
        .detection-meta .fuzzy-warning {
            color: #e67e00;
        }
        .confidence-bar {
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .confidence-fill.high {
            background: #28a745;
        }
        .confidence-fill.medium {
            background: #ffc107;
        }
        .confidence-fill.low {
            background: #dc3545;
        }

        /* Result panel */
        .result {
            text-align: left;
            border: 1px solid #000;
            padding: 15px;
        }
        .result.invalid {
            border-color: #999;
            color: #666;
        }
        .result-row {
            margin: 6px 0;
            display: flex;
            font-size: 0.9rem;
        }
        .result-label {
            width: 110px;
            flex-shrink: 0;
            color: #666;
        }
        .result-value {
            flex: 1;
        }
        .route {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #ccc;
        }
        .route-path {
            font-size: 0.85rem;
            word-break: break-word;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
        }
        .error {
            color: #666;
            font-style: italic;
        }
        .segments {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
        }
        .segments-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 8px;
        }
        .segment-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.8rem;
        }
        .segment-item:last-child {
            border-bottom: none;
        }
        .segment-train-type {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.65rem;
            font-weight: bold;
            border-radius: 3px;
            text-transform: uppercase;
            white-space: nowrap;
        }
        .segment-train-type.tgv {
            background: #3498db;
            color: white;
        }
        .segment-train-type.ter {
            background: #2ecc71;
            color: white;
        }
        .segment-train-type.intercites {
            background: #9b59b6;
            color: white;
        }
        .segment-train-type.transilien {
            background: #e74c3c;
            color: white;
        }
        .segment-train-type.train {
            background: #95a5a6;
            color: white;
        }
        .segment-route {
            flex: 1;
        }
        .segment-duration {
            font-size: 0.7rem;
            color: #666;
            white-space: nowrap;
        }

        /* Loading state */
        .loading-state {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }
    </style>
</head>
<body class="centered model-loading">
    <div class="container">
        <h1>TRAVEL ORDER RESOLVER</h1>

        <div class="search-form">
            <div class="input-wrapper" id="input-wrapper">
                <button type="button" class="mic-btn loading" id="mic-btn" title="Chargement du modele..." disabled>
                    <svg class="mic-icon" viewBox="0 0 24 24" width="20" height="20">
                        <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                        <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                    </svg>
                    <svg class="transcribing-icon" viewBox="0 0 24 24" width="20" height="20">
                        <circle cx="6" cy="12" r="2"/>
                        <circle cx="12" cy="12" r="2"/>
                        <circle cx="18" cy="12" r="2"/>
                    </svg>
                </button>
                <input
                    type="text"
                    id="sentence-input"
                    placeholder="Chargement de la reconnaissance vocale..."
                    autocomplete="off"
                    autofocus
                >
                <button type="button" class="clear-btn" id="clear-btn" title="Effacer">&times;</button>
                <div class="wave-container" id="wave-container">
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                </div>
            </div>
        </div>

        <!-- Sliding Tabs -->
        <div class="tabs-container">
            <div class="tabs">
                <div class="tab-slider"></div>
                <button class="tab active" data-model="spacy" id="tab-spacy">
                    spaCy
                    {% if not spacy_available %}<span class="model-badge unavailable">N/A</span>{% endif %}
                </button>
                <button class="tab" data-model="camembert" id="tab-camembert" {% if not camembert_available %}disabled{% endif %}>
                    CamemBERT
                    {% if not camembert_available %}<span class="model-badge unavailable">N/A</span>{% endif %}
                </button>
                <button class="tab" data-model="compare" id="tab-compare" {% if not camembert_available %}disabled{% endif %}>
                    Comparer
                </button>
            </div>
        </div>

        <div class="loading" id="loading">Analyse en cours</div>

        <!-- Results -->
        <div id="results-area"></div>
    </div>

    <!-- Voice loading indicator -->
    <div class="voice-loading" id="voice-loading">
        <div class="voice-loading-text" id="voice-loading-text">Chargement du modele vocal...</div>
        <div class="voice-loading-bar">
            <div class="voice-loading-fill" id="voice-loading-fill"></div>
        </div>
        <div class="voice-loading-percent" id="voice-loading-percent">0%</div>
    </div>

    <script type="module">
        // Whisper.js import
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.1.2';

        // State management
        const state = {
            currentModel: 'spacy',
            currentSentence: '',
            cache: {
                spacy: null,
                camembert: null
            },
            models: {
                spacy_available: {{ 'true' if spacy_available else 'false' }},
                camembert_available: {{ 'true' if camembert_available else 'false' }}
            }
        };

        // DOM elements
        const sentenceInput = document.getElementById('sentence-input');
        const resultsArea = document.getElementById('results-area');
        const loading = document.getElementById('loading');
        const tabs = document.querySelectorAll('.tab');
        const tabSlider = document.querySelector('.tab-slider');
        const inputWrapper = document.getElementById('input-wrapper');
        const clearBtn = document.getElementById('clear-btn');
        const micBtn = document.getElementById('mic-btn');
        const waveContainer = document.getElementById('wave-container');

        // Clear button functionality
        function updateClearButton() {
            if (sentenceInput.value.length > 0) {
                inputWrapper.classList.add('has-value');
            } else {
                inputWrapper.classList.remove('has-value');
            }
        }

        clearBtn.addEventListener('click', function() {
            sentenceInput.value = '';
            updateClearButton();
            sentenceInput.focus();
            resultsArea.innerHTML = '';
            document.body.classList.add('centered');

            // Nettoyer les query params de l'URL
            window.history.replaceState({}, '', window.location.pathname);

            // Vider le cache
            state.cache.spacy = null;
            state.cache.camembert = null;
            state.currentSentence = '';
        });

        sentenceInput.addEventListener('input', updateClearButton);

        // Initialize tab slider position
        function updateSlider() {
            const activeTab = document.querySelector('.tab.active');
            if (activeTab && tabSlider) {
                tabSlider.style.left = activeTab.offsetLeft + 'px';
                tabSlider.style.width = activeTab.offsetWidth + 'px';
            }
        }

        // Format duration helper
        function formatDuration(minutes) {
            if (!minutes) return '';
            const hours = Math.floor(minutes / 60);
            const mins = Math.floor(minutes % 60);
            if (hours > 0) {
                return `${hours}h${mins.toString().padStart(2, '0')}`;
            }
            return `${mins} min`;
        }

        // Get confidence class
        function getConfidenceClass(confidence) {
            if (confidence >= 0.8) return 'high';
            if (confidence >= 0.5) return 'medium';
            return 'low';
        }

        // Render detection panel HTML
        function renderDetectionPanel(result) {
            if (!result.highlighted_sentence && !result.departure_detection && !result.arrival_detection) {
                return '';
            }

            let html = '<div class="detection-panel"><div class="detection-header">Analyse NLP</div>';

            if (result.highlighted_sentence) {
                html += `<div class="highlighted-sentence">${result.highlighted_sentence}</div>`;
            }

            html += '<div class="detection-details">';

            if (result.departure_detection) {
                const dep = result.departure_detection;
                html += `
                    <div class="detection-item departure">
                        <div class="detection-label">Depart detecte</div>
                        <div class="detection-value">${dep.raw_text}</div>
                        ${dep.matched_city && dep.matched_city !== dep.raw_text ? `
                            <div class="detection-meta">
                                Correspond a: <strong>${dep.matched_city}</strong>
                                ${dep.is_fuzzy ? `<span class="fuzzy-warning">(approximatif: ${Math.round(dep.match_score * 100)}%)</span>` : ''}
                            </div>
                        ` : ''}
                        ${dep.confidence > 0 ? `
                            <div class="confidence-bar">
                                <div class="confidence-fill ${getConfidenceClass(dep.confidence)}" style="width: ${dep.confidence * 100}%"></div>
                            </div>
                            <div class="detection-meta">Confiance: ${Math.round(dep.confidence * 100)}%</div>
                        ` : ''}
                    </div>
                `;
            }

            if (result.arrival_detection) {
                const arr = result.arrival_detection;
                html += `
                    <div class="detection-item arrival">
                        <div class="detection-label">Arrivee detectee</div>
                        <div class="detection-value">${arr.raw_text}</div>
                        ${arr.matched_city && arr.matched_city !== arr.raw_text ? `
                            <div class="detection-meta">
                                Correspond a: <strong>${arr.matched_city}</strong>
                                ${arr.is_fuzzy ? `<span class="fuzzy-warning">(approximatif: ${Math.round(arr.match_score * 100)}%)</span>` : ''}
                            </div>
                        ` : ''}
                        ${arr.confidence > 0 ? `
                            <div class="confidence-bar">
                                <div class="confidence-fill ${getConfidenceClass(arr.confidence)}" style="width: ${arr.confidence * 100}%"></div>
                            </div>
                            <div class="detection-meta">Confiance: ${Math.round(arr.confidence * 100)}%</div>
                        ` : ''}
                    </div>
                `;
            }

            html += '</div></div>';
            return html;
        }

        // Render result panel HTML
        function renderResultPanel(result) {
            if (!result.is_valid) {
                return `
                    <div class="result invalid">
                        <div class="error">${result.error || 'Requête de voyage non reconnue'}</div>
                    </div>
                `;
            }

            let html = '<div class="result">';

            // Departure/Arrival
            html += `
                <div class="result-row">
                    <span class="result-label">Depart:</span>
                    <span class="result-value">${result.departure}${result.departure !== result.departure_station ? ` (${result.departure_station})` : ''}</span>
                </div>
                <div class="result-row">
                    <span class="result-label">Arrivee:</span>
                    <span class="result-value">${result.arrival}${result.arrival !== result.arrival_station ? ` (${result.arrival_station})` : ''}</span>
                </div>
            `;

            // Route
            if (result.route && result.route.length > 0) {
                html += '<div class="route">';
                html += '<div class="result-row"><span class="result-label">Itineraire:</span></div>';
                html += `<div class="route-path">${result.route.join(' → ')}</div>`;

                // Stats
                html += '<div style="margin-top: 10px; display: flex; gap: 20px; flex-wrap: wrap;">';
                if (result.duration_min) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Duree:</span>
                            <span class="result-value"><strong>${formatDuration(result.duration_min)}</strong></span>
                        </div>
                    `;
                }
                if (result.distance_km) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Distance:</span>
                            <span class="result-value">${result.distance_km} km</span>
                        </div>
                    `;
                }
                if (result.num_connections > 0) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Correspondances:</span>
                            <span class="result-value">${result.num_connections - 1}</span>
                        </div>
                    `;
                }
                html += '</div>';

                // Segments
                if (result.segments && result.segments.length > 0) {
                    html += '<div class="segments"><div class="segments-header">Details du trajet</div>';
                    for (const seg of result.segments) {
                        html += `
                            <div class="segment-item">
                                <span class="segment-train-type ${seg.train_type.toLowerCase()}">${seg.train_type}</span>
                                <span class="segment-route">${seg.from_station} → ${seg.to_station}</span>
                                ${seg.duration_min ? `<span class="segment-duration">${formatDuration(seg.duration_min)}</span>` : ''}
                            </div>
                        `;
                    }
                    html += '</div>';
                }

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // Render a single model's result
        function renderModelResult(result, modelName) {
            return `
                <div class="model-title">${modelName}</div>
                ${renderDetectionPanel(result)}
                ${renderResultPanel(result)}
            `;
        }

        // Update display based on current state
        function updateDisplay() {
            const sentence = sentenceInput.value.trim();

            if (!sentence) {
                resultsArea.innerHTML = '';
                document.body.classList.add('centered');
                return;
            }

            document.body.classList.remove('centered');

            if (state.currentModel === 'compare') {
                // Compare mode - show both side by side
                const spacyResult = state.cache.spacy;
                const camembertResult = state.cache.camembert;

                let html = '<div class="results-container compare">';

                // spaCy column
                html += '<div class="result-column">';
                if (spacyResult) {
                    html += renderModelResult(spacyResult, 'spaCy');
                } else {
                    html += '<div class="model-title">spaCy</div><div class="loading-state">Chargement...</div>';
                }
                html += '</div>';

                // CamemBERT column
                html += '<div class="result-column">';
                if (camembertResult) {
                    html += renderModelResult(camembertResult, 'CamemBERT');
                } else {
                    html += '<div class="model-title">CamemBERT</div><div class="loading-state">Chargement...</div>';
                }
                html += '</div>';

                html += '</div>';
                resultsArea.innerHTML = html;

            } else {
                // Single model mode
                const result = state.cache[state.currentModel];

                if (result) {
                    resultsArea.innerHTML = `
                        <div class="results-container single">
                            <div class="result-column">
                                ${renderModelResult(result, state.currentModel === 'spacy' ? 'spaCy' : 'CamemBERT')}
                            </div>
                        </div>
                    `;
                } else {
                    resultsArea.innerHTML = '<div class="loading-state">Chargement...</div>';
                }
            }
        }

        // Fetch results from API
        async function fetchResult(model) {
            const sentence = sentenceInput.value.trim();
            if (!sentence) return null;

            try {
                const response = await fetch(`/api/query?model=${model}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sentence })
                });

                if (!response.ok) throw new Error('API error');
                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                return {
                    is_valid: false,
                    model_name: model,
                    error: 'Erreur de connexion au serveur. Vérifiez votre connexion internet et réessayez.'
                };
            }
        }

        // Run search for a specific model
        async function runSearch(model) {
            const sentence = sentenceInput.value.trim();

            if (!sentence) {
                resultsArea.innerHTML = '';
                document.body.classList.add('centered');
                return;
            }

            document.body.classList.remove('centered');

            // Check if sentence changed - clear cache if so
            if (sentence !== state.currentSentence) {
                state.cache.spacy = null;
                state.cache.camembert = null;
                state.currentSentence = sentence;
            }

            loading.classList.add('visible');

            if (model === 'compare') {
                // Fetch both models
                const promises = [];

                if (!state.cache.spacy && state.models.spacy_available) {
                    promises.push(fetchResult('spacy').then(r => { state.cache.spacy = r; }));
                }
                if (!state.cache.camembert && state.models.camembert_available) {
                    promises.push(fetchResult('camembert').then(r => { state.cache.camembert = r; }));
                }

                await Promise.all(promises);
            } else {
                // Fetch single model if not cached
                if (!state.cache[model]) {
                    state.cache[model] = await fetchResult(model);
                }
            }

            loading.classList.remove('visible');
            updateDisplay();
        }

        // Tab click handler
        function handleTabClick(e) {
            const tab = e.target.closest('.tab');
            if (!tab || tab.disabled) return;

            const model = tab.dataset.model;

            // Update active state
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            state.currentModel = model;

            // Update slider
            updateSlider();

            // Update URL with current sentence and model
            const sentence = sentenceInput.value.trim();
            if (sentence) {
                updateUrl(sentence, model);
            }

            // Run search
            runSearch(model);
        }

        // Track spacebar state for voice recording
        let spacebarHeld = false;

        // Input handler (Enter key + Spacebar for voice)
        function handleInputKeydown(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                startNewSearch();
                return;
            }

            // Spacebar when input is empty = voice recording trigger
            if (e.key === ' ' && sentenceInput.value.length === 0) {
                e.preventDefault(); // Always prevent space from being typed

                if (spacebarHeld) return; // Already handling (key repeat)

                if (!checkVoiceSupport()) return;

                spacebarHeld = true;

                // Show appropriate message based on status
                if (voiceState.status === 'loading') {
                    sentenceInput.placeholder = 'Chargement du modele, veuillez patienter...';
                    return;
                }

                if (voiceState.status === 'transcribing') {
                    sentenceInput.placeholder = 'Transcription en cours, veuillez patienter...';
                    return;
                }

                if (voiceState.status === 'idle') {
                    prepareRecording();
                }
            }
        }

        function handleInputKeyup(e) {
            // Release spacebar = stop recording and start transcription
            if (e.key === ' ' && spacebarHeld) {
                spacebarHeld = false;
                if (voiceState.status === 'recording') {
                    stopRecording();
                } else {
                    // Reset placeholder if we were waiting
                    setVoiceStatus(voiceState.status);
                }
            }
        }

        // Prepare recording: start if model is ready
        async function prepareRecording() {
            // Model not ready yet
            if (!voiceState.transcriber) {
                return;
            }

            try {
                // Only start recording if spacebar is still held
                if (spacebarHeld) {
                    await actuallyStartRecording();
                }
            } catch (error) {
                console.error('Erreur preparation enregistrement:', error);
                setVoiceStatus('idle');
            }
        }

        // Actually start the microphone recording
        async function actuallyStartRecording() {
            try {
                setVoiceStatus('recording');
                voiceState.audioChunks = [];

                voiceState.stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                voiceState.mediaRecorder = new MediaRecorder(voiceState.stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                voiceState.mediaRecorder.ondataavailable = (e) => {
                    voiceState.audioChunks.push(e.data);
                };

                voiceState.mediaRecorder.onstop = () => {
                    transcribeAudio();
                };

                voiceState.mediaRecorder.start();

            } catch (error) {
                console.error('Erreur enregistrement:', error);
                if (error.name === 'NotAllowedError') {
                    micBtn.title = 'Acces microphone refuse';
                } else if (error.name === 'NotFoundError') {
                    micBtn.title = 'Aucun microphone detecte';
                } else {
                    micBtn.title = 'Erreur: ' + error.message;
                }
                setVoiceStatus('idle');
            }
        }

        // Transcribe recorded audio
        async function transcribeAudio() {
            setVoiceStatus('transcribing');

            try {
                const audioBlob = new Blob(voiceState.audioChunks, { type: 'audio/webm' });
                const audioData = await processAudioBlob(audioBlob);

                const result = await voiceState.transcriber(audioData, {
                    language: 'french',
                    task: 'transcribe'
                });

                const text = result.text.trim();
                if (text) {
                    sentenceInput.value = text;
                    updateClearButton();
                    startNewSearch();
                }
            } catch (error) {
                console.error('Erreur transcription:', error);
                micBtn.title = 'Erreur de transcription';
            } finally {
                setVoiceStatus('idle');
            }
        }

        // Handle window blur - stop recording if spacebar was held
        function handleWindowBlur() {
            if (spacebarHeld) {
                spacebarHeld = false;
                if (voiceState.status === 'recording') {
                    stopRecording();
                }
            }
        }

        // Keep focus on input at all times
        function keepFocusOnInput() {
            sentenceInput.focus();
        }

        // Start a new search (clears cache and updates URL)
        function startNewSearch() {
            const sentence = sentenceInput.value.trim();
            if (!sentence) return;

            // Clear cache
            state.cache.spacy = null;
            state.cache.camembert = null;
            state.currentSentence = sentence;

            // Update URL with query params
            updateUrl(sentence, state.currentModel);

            // Run search
            runSearch(state.currentModel);
        }

        // Update URL query params without page reload
        function updateUrl(sentence, model) {
            const params = new URLSearchParams();
            if (sentence) params.set('q', sentence);
            if (model && model !== 'spacy') params.set('model', model);

            const newUrl = params.toString()
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;

            window.history.replaceState({}, '', newUrl);
        }

        // Read query params from URL
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sentence: params.get('q') || '',
                model: params.get('model') || 'spacy'
            };
        }

        // === Whisper.js Voice Recognition ===
        const voiceState = {
            status: 'idle', // idle, loading, recording, transcribing
            transcriber: null,
            mediaRecorder: null,
            audioChunks: [],
            stream: null
        };

        const voiceLoadingEl = document.getElementById('voice-loading');
        const voiceLoadingText = document.getElementById('voice-loading-text');
        const voiceLoadingFill = document.getElementById('voice-loading-fill');
        const voiceLoadingPercent = document.getElementById('voice-loading-percent');

        function setVoiceStatus(status) {
            voiceState.status = status;
            micBtn.classList.remove('idle', 'loading', 'recording', 'transcribing');
            micBtn.classList.add(status);

            const titles = {
                idle: 'Dictee vocale (Whisper)',
                loading: 'Chargement du modele...',
                recording: 'Cliquez pour arreter',
                transcribing: 'Transcription en cours...'
            };
            micBtn.title = titles[status];

            // Handle mic button disabled state
            micBtn.disabled = (status === 'loading');

            // Handle wave animation and input states
            inputWrapper.classList.remove('recording', 'transcribing');
            waveContainer.classList.remove('visible');

            if (status === 'recording') {
                inputWrapper.classList.add('recording');
                waveContainer.classList.add('visible');
                sentenceInput.placeholder = '';
            } else if (status === 'transcribing') {
                inputWrapper.classList.add('transcribing');
                sentenceInput.placeholder = 'Transcription en cours...';
            } else if (status === 'loading') {
                sentenceInput.placeholder = 'Chargement de la reconnaissance vocale...';
            } else {
                sentenceInput.placeholder = 'Je veux aller de Paris a Lyon (maintenir espace = micro)';
            }
        }

        // Throttled progress tracking
        const progressState = {
            lastUpdate: 0,
            throttleMs: 150,
            files: {},
            totalFiles: 6, // Whisper-small has ~6 files
            pendingUpdate: null,
            isComplete: false // Flag to prevent showing after complete
        };

        function updateProgressUI() {
            // Don't update if loading is already complete
            if (progressState.isComplete) return;

            // Calculate overall progress from all files
            const fileProgresses = Object.values(progressState.files);
            if (fileProgresses.length === 0) return;

            const avgProgress = fileProgresses.reduce((a, b) => a + b, 0) / progressState.totalFiles;
            const pct = Math.min(99, Math.round(avgProgress));

            voiceLoadingFill.style.width = `${pct}%`;
            voiceLoadingPercent.textContent = `${pct}%`;
            voiceLoadingEl.classList.add('visible');
        }

        function hideLoadingUI() {
            progressState.isComplete = true;
            if (progressState.pendingUpdate) {
                clearTimeout(progressState.pendingUpdate);
                progressState.pendingUpdate = null;
            }
            voiceLoadingEl.classList.remove('visible');
        }

        function showLoadingProgress(progress) {
            // Ignore callbacks after loading is complete
            if (progressState.isComplete) return;

            if (progress.status === 'progress' && progress.progress !== undefined) {
                // Track per-file progress
                if (progress.file) {
                    progressState.files[progress.file] = progress.progress;
                }

                // Throttle UI updates
                const now = Date.now();
                if (now - progressState.lastUpdate < progressState.throttleMs) {
                    // Schedule update if not already scheduled
                    if (!progressState.pendingUpdate) {
                        progressState.pendingUpdate = setTimeout(() => {
                            progressState.pendingUpdate = null;
                            progressState.lastUpdate = Date.now();
                            updateProgressUI();
                        }, progressState.throttleMs);
                    }
                    return;
                }

                progressState.lastUpdate = now;
                updateProgressUI();
            } else if (progress.status === 'done') {
                // File download complete - show 100% for this file but keep loading visible
                // Model initialization continues after downloads
                if (progress.file) {
                    progressState.files[progress.file] = 100;
                    updateProgressUI();
                }
            }
            // Note: Don't hide on 'ready' - wait for pipeline() to fully resolve
        }

        async function initWhisper() {
            if (voiceState.transcriber) return;

            // Reset progress tracking
            progressState.files = {};
            progressState.lastUpdate = 0;
            progressState.isComplete = false;

            setVoiceStatus('loading');
            voiceLoadingEl.classList.add('visible');
            voiceLoadingFill.style.width = '0%';
            voiceLoadingPercent.textContent = '0%';
            voiceLoadingText.textContent = 'Chargement du site...';

            // Force browser to paint before starting heavy work
            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

            try {
                // Check WebGPU support
                const hasWebGPU = 'gpu' in navigator;

                voiceState.transcriber = await pipeline(
                    'automatic-speech-recognition',
                    'Xenova/whisper-small',
                    {
                        progress_callback: showLoadingProgress,
                        dtype: 'fp32',
                        device: hasWebGPU ? 'webgpu' : 'wasm'
                    }
                );

                console.log(`Whisper loaded with ${hasWebGPU ? 'WebGPU' : 'WASM'} backend`);
                hideLoadingUI();
                document.body.classList.remove('model-loading');
                setVoiceStatus('idle');
                // Focus input after loading
                setTimeout(() => sentenceInput.focus(), 100);
            } catch (error) {
                console.error('Erreur chargement Whisper:', error);
                hideLoadingUI();
                document.body.classList.remove('model-loading');
                micBtn.title = 'Erreur de chargement du modele';
                micBtn.disabled = true;
                setVoiceStatus('idle');
                // Focus input even on error
                setTimeout(() => sentenceInput.focus(), 100);
                throw error;
            }
        }

        function stopRecording() {
            if (voiceState.mediaRecorder && voiceState.mediaRecorder.state === 'recording') {
                voiceState.mediaRecorder.stop();
            }
            if (voiceState.stream) {
                voiceState.stream.getTracks().forEach(track => track.stop());
                voiceState.stream = null;
            }
        }

        async function processAudioBlob(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });

            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            let audioData = audioBuffer.getChannelData(0);

            // Resample to 16kHz if needed
            if (audioBuffer.sampleRate !== 16000) {
                audioData = resampleAudio(audioData, audioBuffer.sampleRate, 16000);
            }

            audioContext.close();
            return audioData;
        }

        function resampleAudio(data, fromRate, toRate) {
            const ratio = fromRate / toRate;
            const newLength = Math.round(data.length / ratio);
            const result = new Float32Array(newLength);

            for (let i = 0; i < newLength; i++) {
                const srcIdx = i * ratio;
                const srcIdxFloor = Math.floor(srcIdx);
                const srcIdxCeil = Math.min(srcIdxFloor + 1, data.length - 1);
                const t = srcIdx - srcIdxFloor;
                result[i] = data[srcIdxFloor] * (1 - t) + data[srcIdxCeil] * t;
            }
            return result;
        }

        async function toggleRecording() {
            // Remove focus to hide tooltip immediately
            micBtn.blur();

            if (voiceState.status === 'loading' || voiceState.status === 'transcribing') {
                return; // Ignore clicks during loading/transcribing
            }

            if (!voiceState.transcriber) {
                return; // Model not loaded yet
            }

            if (voiceState.status === 'recording') {
                stopRecording();
            } else {
                try {
                    await actuallyStartRecording();
                } catch (error) {
                    console.error('Erreur demarrage enregistrement:', error);
                    setVoiceStatus('idle');
                }
            }
        }

        // Check browser support
        function checkVoiceSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                micBtn.disabled = true;
                micBtn.title = 'Microphone non supporte';
                return false;
            }
            return true;
        }

        // Initialize
        function init() {
            // Set up event listeners
            tabs.forEach(tab => tab.addEventListener('click', handleTabClick));
            sentenceInput.addEventListener('keydown', handleInputKeydown);
            sentenceInput.addEventListener('keyup', handleInputKeyup);

            // Initialize voice recognition
            if (checkVoiceSupport()) {
                micBtn.addEventListener('click', toggleRecording);
                // Load Whisper model at startup
                initWhisper().catch(err => {
                    console.error('Failed to load Whisper:', err);
                });
            }

            // Initialize slider position
            setTimeout(updateSlider, 0);
            window.addEventListener('resize', updateSlider);
            window.addEventListener('blur', handleWindowBlur);

            // Keep focus on input at all times
            document.addEventListener('mousedown', (e) => {
                // Allow default only for the input itself
                if (e.target !== sentenceInput) {
                    e.preventDefault();
                    keepFocusOnInput();
                }
            });
            sentenceInput.addEventListener('blur', keepFocusOnInput);

            // Ensure focus on input (some browsers ignore autofocus)
            sentenceInput.focus();

            // Check for query params and auto-search
            const params = getQueryParams();
            if (params.sentence) {
                sentenceInput.value = params.sentence;

                // Set model from URL if valid
                const modelTab = document.querySelector(`.tab[data-model="${params.model}"]`);
                if (modelTab && !modelTab.disabled) {
                    tabs.forEach(t => t.classList.remove('active'));
                    modelTab.classList.add('active');
                    state.currentModel = params.model;
                    setTimeout(updateSlider, 0);
                }

                // Auto-run search
                state.currentSentence = params.sentence;
                runSearch(state.currentModel);
            } else {
                // Show centered empty state initially
                resultsArea.innerHTML = '';
                document.body.classList.add('centered');
            }
        }

        // Start
        init();
    </script>
</body>
</html>
