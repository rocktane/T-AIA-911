<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Order Resolver</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23000'%3E%3Cpath d='M12 2C8 2 4 2.5 4 6v9.5c0 1.93 1.57 3.5 3.5 3.5L6 20.5v.5h2l2-2h4l2 2h2v-.5L16.5 19c1.93 0 3.5-1.57 3.5-3.5V6c0-3.5-4-4-8-4zM7.5 17c-.83 0-1.5-.67-1.5-1.5S6.67 14 7.5 14s1.5.67 1.5 1.5S8.33 17 7.5 17zm3.5-6H6V6h5v5zm2 0V6h5v5h-5zm3.5 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Courier New', monospace;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: #fff;
            color: #000;
            padding: 20px;
            padding-top: 40px;
            transition: justify-content 0.3s ease;
        }
        body.centered {
            justify-content: center;
            padding-top: 20px;
        }

        /* Docs button */
        .docs-btn {
            position: fixed;
            top: 15px;
            right: 20px;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #000;
            background: #fff;
            border: 1px solid #000;
            text-decoration: none;
            transition: all 0.2s ease;
            z-index: 100;
        }
        .docs-btn:hover {
            background: #000;
            color: #fff;
        }

        .container {
            width: 100%;
            max-width: 900px;
            text-align: center;
        }
        h1 {
            font-size: 1.2rem;
            font-weight: normal;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        /* Search form */
        .search-form {
            width: 100%;
            margin-bottom: 20px;
        }
        .input-wrapper {
            position: relative;
            width: 100%;
        }
        input[type="text"] {
            width: 100%;
            padding: 15px 40px 15px 45px;
            font-family: inherit;
            font-size: 1.1rem;
            border: 1px solid #000;
            outline: none;
            text-align: center;
        }
        input[type="text"]:focus {
            border-width: 1px;
        }
        input[type="text"]::placeholder {
            color: #999;
        }
        .clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.2rem;
            color: #999;
            cursor: pointer;
            padding: 5px 10px;
            display: none;
        }
        .clear-btn:hover {
            color: #000;
        }
        .input-wrapper.has-value .clear-btn {
            display: block;
        }

        /* Microphone button */
        .mic-btn {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: color 0.2s ease;
        }
        .mic-btn:hover {
            color: #000;
        }
        .mic-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .mic-icon {
            fill: currentColor;
        }
        .mic-btn.recording {
            color: #dc3545;
        }
        .mic-btn.recording .mic-icon {
            animation: pulse 1s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
        .mic-btn.recording::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid #dc3545;
            border-radius: 50%;
            animation: ring-pulse 1.5s ease-out infinite;
        }
        @keyframes ring-pulse {
            0% { transform: scale(0.8); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        .mic-btn.loading {
            color: #666;
        }
        .mic-btn.loading .mic-icon {
            animation: pulse 1.5s ease-in-out infinite;
        }
        .mic-btn.transcribing {
            color: #2196f3;
        }
        .mic-btn.transcribing .mic-icon {
            display: none;
        }
        .mic-btn .transcribing-icon {
            display: none;
        }
        .mic-btn.transcribing .transcribing-icon {
            display: block;
            fill: currentColor;
            animation: transcribe-pulse 1.2s ease-in-out infinite;
        }
        @keyframes transcribe-pulse {
            0%, 100% { opacity: 0.4; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        /* Wave animation for recording */
        .wave-container {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 3px;
            height: 24px;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .wave-container.visible {
            display: flex;
        }
        .wave-bar {
            width: 4px;
            height: 8px;
            background: #000;
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }
        /* Hide mic button during recording */
        .input-wrapper.recording .mic-btn {
            opacity: 0;
            pointer-events: none;
        }
        .wave-bar:nth-child(1) { animation-delay: 0s; }
        .wave-bar:nth-child(2) { animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { animation-delay: 0.4s; }
        .wave-bar:nth-child(6) { animation-delay: 0.3s; }
        .wave-bar:nth-child(7) { animation-delay: 0.2s; }
        .wave-bar:nth-child(8) { animation-delay: 0.1s; }
        .wave-bar:nth-child(9) { animation-delay: 0s; }
        @keyframes wave {
            0%, 100% { height: 8px; opacity: 0.5; }
            50% { height: 24px; opacity: 1; }
        }
        .input-wrapper.recording input {
            color: transparent;
        }
        .input-wrapper.recording input::placeholder {
            color: transparent;
        }
        /* Hide cursor during transcription */
        .input-wrapper.transcribing input {
            caret-color: transparent;
        }

        /* Smooth transition for main content */
        .search-form,
        .tabs-container {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        /* Hide main content during initial loading */
        body.model-loading .search-form,
        body.model-loading .tabs-container {
            opacity: 0;
            visibility: hidden;
        }

        /* Voice loading indicator - centered during initial load */
        .voice-loading {
            position: fixed;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #fff;
            border: 1px solid #000;
            padding: 20px 35px;
            z-index: 1000;
            text-align: center;
            min-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease, top 0.3s ease;
            top: 50%;
        }
        .voice-loading.visible {
            opacity: 1;
            visibility: visible;
        }
        .voice-loading-text {
            font-size: 0.85rem;
            margin-bottom: 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .voice-loading-bar {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            overflow: hidden;
        }
        .voice-loading-fill {
            height: 100%;
            background: #000;
            width: 0%;
            transition: width 0.3s ease;
        }
        .voice-loading-percent {
            font-size: 0.75rem;
            color: #666;
            margin-top: 5px;
        }

        /* Sliding Tabs */
        .tabs-container {
            margin: 25px 0;
            display: flex;
            justify-content: center;
        }
        .tabs {
            display: inline-flex;
            background: #f0f0f0;
            border-radius: 30px;
            padding: 4px;
            position: relative;
        }
        .tab {
            padding: 10px 24px;
            font-family: inherit;
            font-size: 0.85rem;
            background: transparent;
            border: none;
            cursor: pointer;
            position: relative;
            z-index: 1;
            transition: color 0.3s ease;
            white-space: nowrap;
        }
        .tab:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .tab.active {
            color: #fff;
        }
        .tab:not(.active):not(:disabled):hover {
            color: #333;
        }
        .tab-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            background: #000;
            border-radius: 26px;
            transition: left 0.3s ease, width 0.3s ease;
            z-index: 0;
        }
        .model-badge {
            display: inline-block;
            font-size: 0.65rem;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            vertical-align: middle;
        }
        .model-badge.unavailable {
            background: #ffebee;
            color: #c62828;
        }

        /* Loading indicator */
        .loading {
            display: none;
            margin: 20px 0;
            font-size: 0.9rem;
            color: #666;
        }
        .loading.visible {
            display: block;
        }
        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Results container */
        .results-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        .results-container.single {
            justify-content: center;
        }
        .results-container.compare {
            justify-content: space-between;
        }
        .result-column {
            flex: 1;
            max-width: 100%;
        }
        .results-container.compare .result-column {
            max-width: calc(50% - 10px);
        }
        .model-title {
            font-size: 0.9rem;
            letter-spacing: 1px;
            color: #000;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #000;
        }

        /* Detection panel */
        .detection-panel {
            padding: 15px;
            background: transparent;
            border: 1px solid #000;
            text-align: left;
            margin-bottom: 15px;
        }
        .detection-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
        }
        .highlighted-sentence {
            font-size: 0.95rem;
            line-height: 1.6;
            padding: 10px;
            background: #fff;
            border: 1px dashed #ccc;
            margin-bottom: 15px;
            word-break: break-word;
        }
        .highlight-departure {
            background: #d4edda;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px solid #28a745;
        }
        .highlight-arrival {
            background: #f8d7da;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px solid #dc3545;
        }
        .highlight-via {
            background: #fff3cd;
            padding: 2px 4px;
            border-radius: 3px;
            border-bottom: 2px solid #ffc107;
        }
        .detection-details {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        .detection-item {
            flex: 1;
            min-width: 150px;
            padding: 10px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }
        .detection-item.departure {
            border-left: 3px solid #28a745;
        }
        .detection-item.arrival {
            border-left: 3px solid #dc3545;
        }
        .detection-item.via {
            border-left: 3px solid #ffc107;
        }
        .detection-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 5px;
        }
        .detection-value {
            font-size: 0.95rem;
            font-weight: bold;
        }
        .detection-meta {
            font-size: 0.7rem;
            color: #888;
            margin-top: 5px;
        }
        .detection-meta .fuzzy-warning {
            color: #e67e00;
        }
        .confidence-bar {
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        .confidence-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        .confidence-fill.high {
            background: #28a745;
        }
        .confidence-fill.medium {
            background: #ffc107;
        }
        .confidence-fill.low {
            background: #dc3545;
        }

        /* Result panel */
        .result {
            text-align: left;
            border: 1px solid #000;
            padding: 15px;
        }
        .result.invalid {
            border-color: #999;
            color: #666;
        }
        .result-row {
            margin: 6px 0;
            display: flex;
            font-size: 0.9rem;
        }
        .result-label {
            width: 130px;
            flex-shrink: 0;
            color: #666;
        }
        .result-value {
            flex: 1;
        }
        .route {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #ccc;
        }
        .route-path {
            font-size: 0.85rem;
            word-break: break-word;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
        }
        .error {
            color: #666;
            font-style: italic;
        }
        .segments {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e0e0e0;
        }
        .segments-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 8px;
        }
        .segment-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.8rem;
        }
        .segment-item:last-child {
            border-bottom: none;
        }
        .segment-train-type {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.65rem;
            font-weight: bold;
            border-radius: 3px;
            text-transform: uppercase;
            white-space: nowrap;
        }
        .segment-train-type.tgv {
            background: #3498db;
            color: white;
        }
        .segment-train-type.ter {
            background: #2ecc71;
            color: white;
        }
        .segment-train-type.intercites {
            background: #9b59b6;
            color: white;
        }
        .segment-train-type.transilien {
            background: #e74c3c;
            color: white;
        }
        .segment-train-type.train {
            background: #95a5a6;
            color: white;
        }
        .segment-route {
            flex: 1;
        }
        .segment-duration {
            font-size: 0.7rem;
            color: #666;
            white-space: nowrap;
        }

        /* Loading state */
        .loading-state {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        /* Documentation page styles */
        .docs-page {
            display: none;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            text-align: left;
        }
        .docs-page.visible {
            display: block;
        }
        .docs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 1px solid #000;
        }
        .docs-title {
            font-size: 1.2rem;
            font-weight: normal;
            letter-spacing: 2px;
        }
        .back-btn {
            padding: 8px 16px;
            font-family: inherit;
            font-size: 0.85rem;
            color: #000;
            background: #fff;
            border: 1px solid #000;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .back-btn:hover {
            background: #000;
            color: #fff;
        }
        .category {
            margin-bottom: 30px;
        }
        .category-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #666;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
        }
        .terms-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .term-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .term-item:hover {
            border-color: #000;
            background: #f8f8f8;
        }
        .term-item.active {
            border-color: #000;
            background: #f0f0f0;
        }
        .term-name {
            font-weight: bold;
            font-size: 0.95rem;
        }
        .term-arrow {
            color: #999;
            transition: transform 0.2s ease;
        }
        .term-item.active .term-arrow {
            transform: rotate(90deg);
        }
        .term-content {
            display: none;
            padding: 20px;
            border: 1px solid #000;
            border-top: none;
            background: #fafafa;
            font-size: 0.9rem;
            line-height: 1.7;
        }
        .term-content.visible {
            display: block;
        }
        .term-content h1, .term-content h2 {
            font-size: 1.1rem;
            margin-bottom: 15px;
        }
        .term-content h3 {
            font-size: 0.95rem;
            margin: 20px 0 10px;
        }
        .term-content p {
            margin-bottom: 12px;
        }
        .term-content ul, .term-content ol {
            margin: 10px 0 10px 20px;
        }
        .term-content li {
            margin-bottom: 5px;
        }
        .term-content pre {
            background: #f5f5f5;
            color: #000;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
            font-size: 0.85rem;
            line-height: 1.4;
            border: 1px solid #ddd;
        }
        .term-content code {
            background: #f0f0f0;
            padding: 2px 5px;
            font-size: 0.9em;
        }
        .term-content pre code {
            background: none;
            padding: 0;
        }
        .term-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 0.85rem;
        }
        .term-content th, .term-content td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: left;
        }
        .term-content th {
            background: #f0f0f0;
        }
        .term-content hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 20px 0;
        }

        /* Hide main app when docs visible */
        body.docs-visible .container,
        body.docs-visible .voice-loading {
            display: none;
        }
        body.docs-visible .docs-btn {
            display: none;
        }
        body.docs-visible {
            justify-content: flex-start;
            padding-top: 40px;
        }
    </style>
</head>
<body class="centered model-loading">
    <a href="/docs" class="docs-btn">Docs</a>
    <div class="container">
        <h1>TRAVEL ORDER RESOLVER</h1>

        <div class="search-form">
            <div class="input-wrapper" id="input-wrapper">
                <button type="button" class="mic-btn loading" id="mic-btn" title="Chargement du modele..." disabled>
                    <svg class="mic-icon" viewBox="0 0 24 24" width="20" height="20">
                        <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                        <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                    </svg>
                    <svg class="transcribing-icon" viewBox="0 0 24 24" width="20" height="20">
                        <circle cx="6" cy="12" r="2"/>
                        <circle cx="12" cy="12" r="2"/>
                        <circle cx="18" cy="12" r="2"/>
                    </svg>
                </button>
                <input
                    type="text"
                    id="sentence-input"
                    placeholder="Chargement de la reconnaissance vocale..."
                    autocomplete="off"
                    autofocus
                >
                <button type="button" class="clear-btn" id="clear-btn" title="Effacer">&times;</button>
                <div class="wave-container" id="wave-container">
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                </div>
            </div>
        </div>

        <!-- Sliding Tabs -->
        <div class="tabs-container">
            <div class="tabs">
                <div class="tab-slider"></div>
                <button class="tab active" data-model="spacy" id="tab-spacy">
                    spaCy
                    {% if not spacy_available %}<span class="model-badge unavailable">N/A</span>{% endif %}
                </button>
                <button class="tab" data-model="camembert" id="tab-camembert" {% if not camembert_available %}disabled{% endif %}>
                    CamemBERT
                    {% if not camembert_available %}<span class="model-badge unavailable">N/A</span>{% endif %}
                </button>
                <button class="tab" data-model="compare" id="tab-compare" {% if not camembert_available %}disabled{% endif %}>
                    Comparer
                </button>
            </div>
        </div>

        <div class="loading" id="loading">Analyse en cours</div>

        <!-- Results -->
        <div id="results-area"></div>
    </div>

    <!-- Voice loading indicator -->
    <div class="voice-loading" id="voice-loading">
        <div class="voice-loading-text" id="voice-loading-text">Chargement du modele vocal...</div>
        <div class="voice-loading-bar">
            <div class="voice-loading-fill" id="voice-loading-fill"></div>
        </div>
        <div class="voice-loading-percent" id="voice-loading-percent">0%</div>
    </div>

    <!-- Documentation page (SPA) -->
    <div class="docs-page" id="docs-page">
        <header class="docs-header">
            <h1 class="docs-title">DOCUMENTATION</h1>
            <button class="back-btn" id="back-btn">Retour</button>
        </header>

        <div class="category">
            <div class="category-title">Concepts fondamentaux</div>
            <div class="terms-list">
                <div class="term-item" data-term="pourquoi_ces_modeles"><span class="term-name">Pourquoi spaCy et CamemBERT ?</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="pourquoi_ces_modeles"></div>
                <div class="term-item" data-term="Schema_BIO"><span class="term-name">Schema BIO</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Schema_BIO"></div>
                <div class="term-item" data-term="Tokenization_BPE"><span class="term-name">Tokenization BPE</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Tokenization_BPE"></div>
                <div class="term-item" data-term="Metriques_NER"><span class="term-name">Metriques NER</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Metriques_NER"></div>
                <div class="term-item" data-term="F1Score"><span class="term-name">F1-Score</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="F1Score"></div>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Architecture spaCy</div>
            <div class="terms-list">
                <div class="term-item" data-term="entrainement_spacy"><span class="term-name">Entrainement spaCy</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="entrainement_spacy"></div>
                <div class="term-item" data-term="Tok2Vec"><span class="term-name">Tok2Vec</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Tok2Vec"></div>
                <div class="term-item" data-term="Tok2VecListener"><span class="term-name">Tok2VecListener</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Tok2VecListener"></div>
                <div class="term-item" data-term="MultiHashEmbed"><span class="term-name">MultiHashEmbed</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="MultiHashEmbed"></div>
                <div class="term-item" data-term="MaxoutWindowEncoder"><span class="term-name">MaxoutWindowEncoder</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="MaxoutWindowEncoder"></div>
                <div class="term-item" data-term="TransitionBasedParser"><span class="term-name">TransitionBasedParser</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="TransitionBasedParser"></div>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Architecture CamemBERT</div>
            <div class="terms-list">
                <div class="term-item" data-term="entrainement_camembert"><span class="term-name">Entrainement CamemBERT</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="entrainement_camembert"></div>
                <div class="term-item" data-term="Transformer"><span class="term-name">Transformer</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Transformer"></div>
                <div class="term-item" data-term="Fine_tuning"><span class="term-name">Fine-tuning</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Fine_tuning"></div>
            </div>
        </div>

        <div class="category">
            <div class="category-title">Techniques d'entrainement</div>
            <div class="terms-list">
                <div class="term-item" data-term="AdamOptimizer"><span class="term-name">Optimiseur Adam</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="AdamOptimizer"></div>
                <div class="term-item" data-term="Warmup"><span class="term-name">Warmup</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Warmup"></div>
                <div class="term-item" data-term="Dropout"><span class="term-name">Dropout</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="Dropout"></div>
                <div class="term-item" data-term="EarlyStopping"><span class="term-name">Early Stopping</span><span class="term-arrow">&#9654;</span></div>
                <div class="term-content" id="EarlyStopping"></div>
            </div>
        </div>
    </div>

    <!-- Markdown libs -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <script type="module">
        // Whisper.js import
        import { pipeline } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.1.2';

        // State management
        const state = {
            currentModel: 'spacy',
            currentSentence: '',
            cache: {
                spacy: null,
                camembert: null
            },
            models: {
                spacy_available: {{ 'true' if spacy_available else 'false' }},
                camembert_available: {{ 'true' if camembert_available else 'false' }}
            }
        };

        // DOM elements
        const sentenceInput = document.getElementById('sentence-input');
        const resultsArea = document.getElementById('results-area');
        const loading = document.getElementById('loading');
        const tabs = document.querySelectorAll('.tab');
        const tabSlider = document.querySelector('.tab-slider');
        const inputWrapper = document.getElementById('input-wrapper');
        const clearBtn = document.getElementById('clear-btn');
        const micBtn = document.getElementById('mic-btn');
        const waveContainer = document.getElementById('wave-container');

        // Clear button functionality
        function updateClearButton() {
            if (sentenceInput.value.length > 0) {
                inputWrapper.classList.add('has-value');
            } else {
                inputWrapper.classList.remove('has-value');
            }
        }

        clearBtn.addEventListener('click', function() {
            sentenceInput.value = '';
            updateClearButton();
            sentenceInput.focus();
            resultsArea.innerHTML = '';
            document.body.classList.add('centered');

            // Nettoyer les query params de l'URL
            window.history.replaceState({}, '', window.location.pathname);

            // Vider le cache
            state.cache.spacy = null;
            state.cache.camembert = null;
            state.currentSentence = '';
        });

        sentenceInput.addEventListener('input', updateClearButton);

        // Initialize tab slider position
        function updateSlider() {
            const activeTab = document.querySelector('.tab.active');
            if (activeTab && tabSlider) {
                tabSlider.style.left = activeTab.offsetLeft + 'px';
                tabSlider.style.width = activeTab.offsetWidth + 'px';
            }
        }

        // Format duration helper
        function formatDuration(minutes) {
            if (!minutes) return '';
            const hours = Math.floor(minutes / 60);
            const mins = Math.floor(minutes % 60);
            if (hours > 0) {
                return `${hours}h${mins.toString().padStart(2, '0')}`;
            }
            return `${mins} min`;
        }

        // Get confidence class
        function getConfidenceClass(confidence) {
            if (confidence >= 0.8) return 'high';
            if (confidence >= 0.5) return 'medium';
            return 'low';
        }

        // Render detection panel HTML
        function renderDetectionPanel(result) {
            if (!result.highlighted_sentence && !result.departure_detection && !result.arrival_detection) {
                return '';
            }

            let html = '<div class="detection-panel"><div class="detection-header">Analyse NLP</div>';

            if (result.highlighted_sentence) {
                html += `<div class="highlighted-sentence">${result.highlighted_sentence}</div>`;
            }

            html += '<div class="detection-details">';

            if (result.departure_detection) {
                const dep = result.departure_detection;
                html += `
                    <div class="detection-item departure">
                        <div class="detection-label">Depart detecte</div>
                        <div class="detection-value">${dep.raw_text}</div>
                        ${dep.matched_city && dep.matched_city !== dep.raw_text ? `
                            <div class="detection-meta">
                                Correspond a: <strong>${dep.matched_city}</strong>
                                ${dep.is_fuzzy ? `<span class="fuzzy-warning">(approximatif: ${Math.round(dep.match_score * 100)}%)</span>` : ''}
                            </div>
                        ` : ''}
                        ${dep.confidence > 0 ? `
                            <div class="confidence-bar">
                                <div class="confidence-fill ${getConfidenceClass(dep.confidence)}" style="width: ${dep.confidence * 100}%"></div>
                            </div>
                            <div class="detection-meta">Confiance: ${Math.round(dep.confidence * 100)}%</div>
                        ` : ''}
                    </div>
                `;
            }

            if (result.arrival_detection) {
                const arr = result.arrival_detection;
                html += `
                    <div class="detection-item arrival">
                        <div class="detection-label">Arrivee detectee</div>
                        <div class="detection-value">${arr.raw_text}</div>
                        ${arr.matched_city && arr.matched_city !== arr.raw_text ? `
                            <div class="detection-meta">
                                Correspond a: <strong>${arr.matched_city}</strong>
                                ${arr.is_fuzzy ? `<span class="fuzzy-warning">(approximatif: ${Math.round(arr.match_score * 100)}%)</span>` : ''}
                            </div>
                        ` : ''}
                        ${arr.confidence > 0 ? `
                            <div class="confidence-bar">
                                <div class="confidence-fill ${getConfidenceClass(arr.confidence)}" style="width: ${arr.confidence * 100}%"></div>
                            </div>
                            <div class="detection-meta">Confiance: ${Math.round(arr.confidence * 100)}%</div>
                        ` : ''}
                    </div>
                `;
            }

            // VIA detections
            if (result.via_detections && result.via_detections.length > 0) {
                for (let i = 0; i < result.via_detections.length; i++) {
                    const via = result.via_detections[i];
                    html += `
                        <div class="detection-item via">
                            <div class="detection-label">Etape ${i + 1} (VIA)</div>
                            <div class="detection-value">${via.raw_text}</div>
                            ${via.matched_city && via.matched_city !== via.raw_text ? `
                                <div class="detection-meta">
                                    Correspond a: <strong>${via.matched_city}</strong>
                                </div>
                            ` : ''}
                            ${via.confidence > 0 ? `
                                <div class="confidence-bar">
                                    <div class="confidence-fill ${getConfidenceClass(via.confidence)}" style="width: ${via.confidence * 100}%"></div>
                                </div>
                                <div class="detection-meta">Confiance: ${Math.round(via.confidence * 100)}%</div>
                            ` : ''}
                        </div>
                    `;
                }
            }

            html += '</div></div>';
            return html;
        }

        // Render result panel HTML
        function renderResultPanel(result) {
            if (!result.is_valid) {
                return `
                    <div class="result invalid">
                        <div class="error">${result.error || 'Requête de voyage non reconnue'}</div>
                    </div>
                `;
            }

            let html = '<div class="result">';

            // Departure/Arrival
            html += `
                <div class="result-row">
                    <span class="result-label">Depart:</span>
                    <span class="result-value">${result.departure}${result.departure !== result.departure_station ? ` (${result.departure_station})` : ''}</span>
                </div>
            `;

            // VIA cities and stations
            if (result.via_stations && result.via_stations.length > 0) {
                const viaItems = result.via_stations.map(v =>
                    v.city !== v.station ? `${v.city} (${v.station})` : v.city
                ).join(' → ');
                html += `
                    <div class="result-row">
                        <span class="result-label">Via:</span>
                        <span class="result-value">${viaItems}</span>
                    </div>
                `;
            } else if (result.via_cities && result.via_cities.length > 0) {
                html += `
                    <div class="result-row">
                        <span class="result-label">Via:</span>
                        <span class="result-value">${result.via_cities.join(' → ')}</span>
                    </div>
                `;
            }

            html += `
                <div class="result-row">
                    <span class="result-label">Arrivee:</span>
                    <span class="result-value">${result.arrival}${result.arrival !== result.arrival_station ? ` (${result.arrival_station})` : ''}</span>
                </div>
            `;

            // Route
            if (result.route && result.route.length > 0) {
                html += '<div class="route">';
                html += '<div class="result-row"><span class="result-label">Itineraire:</span></div>';
                html += `<div class="route-path">${result.route.join(' → ')}</div>`;

                // Stats
                html += '<div style="margin-top: 10px; display: flex; gap: 20px; flex-wrap: wrap;">';
                if (result.duration_min) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Duree:</span>
                            <span class="result-value"><strong>${formatDuration(result.duration_min)}</strong></span>
                        </div>
                    `;
                }
                if (result.distance_km) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Distance:</span>
                            <span class="result-value">${result.distance_km} km</span>
                        </div>
                    `;
                }
                if (result.num_connections > 0) {
                    html += `
                        <div class="result-row" style="margin: 0;">
                            <span class="result-label">Correspondances:</span>
                            <span class="result-value">${result.num_connections - 1}</span>
                        </div>
                    `;
                }
                html += '</div>';

                // Segments
                if (result.segments && result.segments.length > 0) {
                    html += '<div class="segments"><div class="segments-header">Details du trajet</div>';
                    for (const seg of result.segments) {
                        html += `
                            <div class="segment-item">
                                <span class="segment-train-type ${seg.train_type.toLowerCase()}">${seg.train_type}</span>
                                <span class="segment-route">${seg.from_station} → ${seg.to_station}</span>
                                ${seg.duration_min ? `<span class="segment-duration">${formatDuration(seg.duration_min)}</span>` : ''}
                            </div>
                        `;
                    }
                    html += '</div>';
                }

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // Render a single model's result
        function renderModelResult(result, modelName) {
            return `
                <div class="model-title">${modelName}</div>
                ${renderDetectionPanel(result)}
                ${renderResultPanel(result)}
            `;
        }

        // Update display based on current state
        function updateDisplay() {
            const sentence = sentenceInput.value.trim();

            if (!sentence) {
                resultsArea.innerHTML = '';
                document.body.classList.add('centered');
                return;
            }

            document.body.classList.remove('centered');

            if (state.currentModel === 'compare') {
                // Compare mode - show both side by side
                const spacyResult = state.cache.spacy;
                const camembertResult = state.cache.camembert;

                let html = '<div class="results-container compare">';

                // spaCy column
                html += '<div class="result-column">';
                if (spacyResult) {
                    html += renderModelResult(spacyResult, 'spaCy');
                } else {
                    html += '<div class="model-title">spaCy</div><div class="loading-state">Chargement...</div>';
                }
                html += '</div>';

                // CamemBERT column
                html += '<div class="result-column">';
                if (camembertResult) {
                    html += renderModelResult(camembertResult, 'CamemBERT');
                } else {
                    html += '<div class="model-title">CamemBERT</div><div class="loading-state">Chargement...</div>';
                }
                html += '</div>';

                html += '</div>';
                resultsArea.innerHTML = html;

            } else {
                // Single model mode
                const result = state.cache[state.currentModel];

                if (result) {
                    resultsArea.innerHTML = `
                        <div class="results-container single">
                            <div class="result-column">
                                ${renderModelResult(result, state.currentModel === 'spacy' ? 'spaCy' : 'CamemBERT')}
                            </div>
                        </div>
                    `;
                } else {
                    resultsArea.innerHTML = '<div class="loading-state">Chargement...</div>';
                }
            }
        }

        // Fetch results from API
        async function fetchResult(model) {
            const sentence = sentenceInput.value.trim();
            if (!sentence) return null;

            try {
                const response = await fetch(`/api/query?model=${model}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sentence })
                });

                if (!response.ok) throw new Error('API error');
                return await response.json();
            } catch (error) {
                console.error('Fetch error:', error);
                return {
                    is_valid: false,
                    model_name: model,
                    error: 'Erreur de connexion au serveur. Vérifiez votre connexion internet et réessayez.'
                };
            }
        }

        // Run search for a specific model
        async function runSearch(model) {
            const sentence = sentenceInput.value.trim();

            if (!sentence) {
                resultsArea.innerHTML = '';
                document.body.classList.add('centered');
                return;
            }

            document.body.classList.remove('centered');

            // Check if sentence changed - clear cache if so
            if (sentence !== state.currentSentence) {
                state.cache.spacy = null;
                state.cache.camembert = null;
                state.currentSentence = sentence;
            }

            loading.classList.add('visible');

            if (model === 'compare') {
                // Fetch both models
                const promises = [];

                if (!state.cache.spacy && state.models.spacy_available) {
                    promises.push(fetchResult('spacy').then(r => { state.cache.spacy = r; }));
                }
                if (!state.cache.camembert && state.models.camembert_available) {
                    promises.push(fetchResult('camembert').then(r => { state.cache.camembert = r; }));
                }

                await Promise.all(promises);
            } else {
                // Fetch single model if not cached
                if (!state.cache[model]) {
                    state.cache[model] = await fetchResult(model);
                }
            }

            loading.classList.remove('visible');
            updateDisplay();
        }

        // Tab click handler
        function handleTabClick(e) {
            const tab = e.target.closest('.tab');
            if (!tab || tab.disabled) return;

            const model = tab.dataset.model;

            // Update active state
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            state.currentModel = model;

            // Update slider
            updateSlider();

            // Update URL with current sentence and model
            const sentence = sentenceInput.value.trim();
            if (sentence) {
                updateUrl(sentence, model);
            }

            // Run search
            runSearch(model);
        }

        // Track spacebar state for voice recording
        let spacebarHeld = false;

        // Input handler (Enter key + Spacebar for voice)
        function handleInputKeydown(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                startNewSearch();
                return;
            }

            // Spacebar when input is empty = voice recording trigger
            if (e.key === ' ' && sentenceInput.value.length === 0) {
                e.preventDefault(); // Always prevent space from being typed

                if (spacebarHeld) return; // Already handling (key repeat)

                if (!checkVoiceSupport()) return;

                spacebarHeld = true;

                // Show appropriate message based on status
                if (voiceState.status === 'loading') {
                    sentenceInput.placeholder = 'Chargement du modele, veuillez patienter...';
                    return;
                }

                if (voiceState.status === 'transcribing') {
                    sentenceInput.placeholder = 'Transcription en cours, veuillez patienter...';
                    return;
                }

                if (voiceState.status === 'idle') {
                    prepareRecording();
                }
            }
        }

        function handleInputKeyup(e) {
            // Release spacebar = stop recording and start transcription
            if (e.key === ' ' && spacebarHeld) {
                spacebarHeld = false;
                if (voiceState.status === 'recording') {
                    stopRecording();
                } else {
                    // Reset placeholder if we were waiting
                    setVoiceStatus(voiceState.status);
                }
            }
        }

        // Prepare recording: start if model is ready
        async function prepareRecording() {
            // Model not ready yet
            if (!voiceState.transcriber) {
                return;
            }

            try {
                // Only start recording if spacebar is still held
                if (spacebarHeld) {
                    await actuallyStartRecording();
                }
            } catch (error) {
                console.error('Erreur preparation enregistrement:', error);
                setVoiceStatus('idle');
            }
        }

        // Actually start the microphone recording
        async function actuallyStartRecording() {
            try {
                setVoiceStatus('recording');
                voiceState.audioChunks = [];

                voiceState.stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });

                voiceState.mediaRecorder = new MediaRecorder(voiceState.stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });

                voiceState.mediaRecorder.ondataavailable = (e) => {
                    voiceState.audioChunks.push(e.data);
                };

                voiceState.mediaRecorder.onstop = () => {
                    transcribeAudio();
                };

                voiceState.mediaRecorder.start();

            } catch (error) {
                console.error('Erreur enregistrement:', error);
                if (error.name === 'NotAllowedError') {
                    micBtn.title = 'Acces microphone refuse';
                } else if (error.name === 'NotFoundError') {
                    micBtn.title = 'Aucun microphone detecte';
                } else {
                    micBtn.title = 'Erreur: ' + error.message;
                }
                setVoiceStatus('idle');
            }
        }

        // Transcribe recorded audio
        async function transcribeAudio() {
            setVoiceStatus('transcribing');

            try {
                const audioBlob = new Blob(voiceState.audioChunks, { type: 'audio/webm' });
                const audioData = await processAudioBlob(audioBlob);

                const result = await voiceState.transcriber(audioData, {
                    language: 'french',
                    task: 'transcribe'
                });

                const text = result.text.trim();
                if (text) {
                    sentenceInput.value = text;
                    updateClearButton();
                    startNewSearch();
                }
            } catch (error) {
                console.error('Erreur transcription:', error);
                micBtn.title = 'Erreur de transcription';
            } finally {
                setVoiceStatus('idle');
            }
        }

        // Handle window blur - stop recording if spacebar was held
        function handleWindowBlur() {
            if (spacebarHeld) {
                spacebarHeld = false;
                if (voiceState.status === 'recording') {
                    stopRecording();
                }
            }
        }

        // Keep focus on input at all times
        function keepFocusOnInput() {
            sentenceInput.focus();
        }

        // Start a new search (clears cache and updates URL)
        function startNewSearch() {
            const sentence = sentenceInput.value.trim();
            if (!sentence) return;

            // Clear cache
            state.cache.spacy = null;
            state.cache.camembert = null;
            state.currentSentence = sentence;

            // Update URL with query params
            updateUrl(sentence, state.currentModel);

            // Run search
            runSearch(state.currentModel);
        }

        // Update URL query params without page reload
        function updateUrl(sentence, model) {
            const params = new URLSearchParams();
            if (sentence) params.set('q', sentence);
            if (model && model !== 'spacy') params.set('model', model);

            const newUrl = params.toString()
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;

            window.history.replaceState({}, '', newUrl);
        }

        // Read query params from URL
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                sentence: params.get('q') || '',
                model: params.get('model') || 'spacy'
            };
        }

        // === Whisper.js Voice Recognition ===
        const voiceState = {
            status: 'idle', // idle, loading, recording, transcribing
            transcriber: null,
            mediaRecorder: null,
            audioChunks: [],
            stream: null
        };

        const voiceLoadingEl = document.getElementById('voice-loading');
        const voiceLoadingText = document.getElementById('voice-loading-text');
        const voiceLoadingFill = document.getElementById('voice-loading-fill');
        const voiceLoadingPercent = document.getElementById('voice-loading-percent');

        function setVoiceStatus(status) {
            voiceState.status = status;
            micBtn.classList.remove('idle', 'loading', 'recording', 'transcribing');
            micBtn.classList.add(status);

            const titles = {
                idle: 'Dictee vocale (Whisper)',
                loading: 'Chargement du modele...',
                recording: 'Cliquez pour arreter',
                transcribing: 'Transcription en cours...'
            };
            micBtn.title = titles[status];

            // Handle mic button disabled state
            micBtn.disabled = (status === 'loading');

            // Handle wave animation and input states
            inputWrapper.classList.remove('recording', 'transcribing');
            waveContainer.classList.remove('visible');

            if (status === 'recording') {
                inputWrapper.classList.add('recording');
                waveContainer.classList.add('visible');
                sentenceInput.placeholder = '';
            } else if (status === 'transcribing') {
                inputWrapper.classList.add('transcribing');
                sentenceInput.placeholder = 'Transcription en cours...';
            } else if (status === 'loading') {
                sentenceInput.placeholder = 'Chargement de la reconnaissance vocale...';
            } else {
                sentenceInput.placeholder = 'Je veux aller de Paris a Lyon (maintenir espace = micro)';
            }
        }

        // Throttled progress tracking
        const progressState = {
            lastUpdate: 0,
            throttleMs: 150,
            files: {},
            totalFiles: 6, // Whisper-small has ~6 files
            pendingUpdate: null,
            isComplete: false // Flag to prevent showing after complete
        };

        function updateProgressUI() {
            // Don't update if loading is already complete
            if (progressState.isComplete) return;

            // Calculate overall progress from all files
            const fileProgresses = Object.values(progressState.files);
            if (fileProgresses.length === 0) return;

            const avgProgress = fileProgresses.reduce((a, b) => a + b, 0) / progressState.totalFiles;
            const pct = Math.min(99, Math.round(avgProgress));

            voiceLoadingFill.style.width = `${pct}%`;
            voiceLoadingPercent.textContent = `${pct}%`;
            voiceLoadingEl.classList.add('visible');
        }

        function hideLoadingUI() {
            progressState.isComplete = true;
            if (progressState.pendingUpdate) {
                clearTimeout(progressState.pendingUpdate);
                progressState.pendingUpdate = null;
            }
            voiceLoadingEl.classList.remove('visible');
        }

        function showLoadingProgress(progress) {
            // Ignore callbacks after loading is complete
            if (progressState.isComplete) return;

            if (progress.status === 'progress' && progress.progress !== undefined) {
                // Track per-file progress
                if (progress.file) {
                    progressState.files[progress.file] = progress.progress;
                }

                // Throttle UI updates
                const now = Date.now();
                if (now - progressState.lastUpdate < progressState.throttleMs) {
                    // Schedule update if not already scheduled
                    if (!progressState.pendingUpdate) {
                        progressState.pendingUpdate = setTimeout(() => {
                            progressState.pendingUpdate = null;
                            progressState.lastUpdate = Date.now();
                            updateProgressUI();
                        }, progressState.throttleMs);
                    }
                    return;
                }

                progressState.lastUpdate = now;
                updateProgressUI();
            } else if (progress.status === 'done') {
                // File download complete - show 100% for this file but keep loading visible
                // Model initialization continues after downloads
                if (progress.file) {
                    progressState.files[progress.file] = 100;
                    updateProgressUI();
                }
            }
            // Note: Don't hide on 'ready' - wait for pipeline() to fully resolve
        }

        async function initWhisper() {
            if (voiceState.transcriber) return;

            // Reset progress tracking
            progressState.files = {};
            progressState.lastUpdate = 0;
            progressState.isComplete = false;

            setVoiceStatus('loading');
            voiceLoadingEl.classList.add('visible');
            voiceLoadingFill.style.width = '0%';
            voiceLoadingPercent.textContent = '0%';
            voiceLoadingText.textContent = 'Chargement du site...';

            // Force browser to paint before starting heavy work
            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

            try {
                // Check WebGPU support
                const hasWebGPU = 'gpu' in navigator;

                voiceState.transcriber = await pipeline(
                    'automatic-speech-recognition',
                    'Xenova/whisper-small',
                    {
                        progress_callback: showLoadingProgress,
                        dtype: 'fp32',
                        device: hasWebGPU ? 'webgpu' : 'wasm'
                    }
                );

                console.log(`Whisper loaded with ${hasWebGPU ? 'WebGPU' : 'WASM'} backend`);
                hideLoadingUI();
                document.body.classList.remove('model-loading');
                setVoiceStatus('idle');
                // Focus input after loading
                setTimeout(() => sentenceInput.focus(), 100);
            } catch (error) {
                console.error('Erreur chargement Whisper:', error);
                hideLoadingUI();
                document.body.classList.remove('model-loading');
                micBtn.title = 'Erreur de chargement du modele';
                micBtn.disabled = true;
                setVoiceStatus('idle');
                // Focus input even on error
                setTimeout(() => sentenceInput.focus(), 100);
                throw error;
            }
        }

        function stopRecording() {
            if (voiceState.mediaRecorder && voiceState.mediaRecorder.state === 'recording') {
                voiceState.mediaRecorder.stop();
            }
            if (voiceState.stream) {
                voiceState.stream.getTracks().forEach(track => track.stop());
                voiceState.stream = null;
            }
        }

        async function processAudioBlob(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const audioContext = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 16000
            });

            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            let audioData = audioBuffer.getChannelData(0);

            // Resample to 16kHz if needed
            if (audioBuffer.sampleRate !== 16000) {
                audioData = resampleAudio(audioData, audioBuffer.sampleRate, 16000);
            }

            audioContext.close();
            return audioData;
        }

        function resampleAudio(data, fromRate, toRate) {
            const ratio = fromRate / toRate;
            const newLength = Math.round(data.length / ratio);
            const result = new Float32Array(newLength);

            for (let i = 0; i < newLength; i++) {
                const srcIdx = i * ratio;
                const srcIdxFloor = Math.floor(srcIdx);
                const srcIdxCeil = Math.min(srcIdxFloor + 1, data.length - 1);
                const t = srcIdx - srcIdxFloor;
                result[i] = data[srcIdxFloor] * (1 - t) + data[srcIdxCeil] * t;
            }
            return result;
        }

        async function toggleRecording() {
            // Remove focus to hide tooltip immediately
            micBtn.blur();

            if (voiceState.status === 'loading' || voiceState.status === 'transcribing') {
                return; // Ignore clicks during loading/transcribing
            }

            if (!voiceState.transcriber) {
                return; // Model not loaded yet
            }

            if (voiceState.status === 'recording') {
                stopRecording();
            } else {
                try {
                    await actuallyStartRecording();
                } catch (error) {
                    console.error('Erreur demarrage enregistrement:', error);
                    setVoiceStatus('idle');
                }
            }
        }

        // Check browser support
        function checkVoiceSupport() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                micBtn.disabled = true;
                micBtn.title = 'Microphone non supporte';
                return false;
            }
            return true;
        }

        // === Documentation SPA ===
        const docsPage = document.getElementById('docs-page');
        const docsBtn = document.querySelector('.docs-btn');
        const backBtn = document.getElementById('back-btn');
        const termItems = document.querySelectorAll('.term-item');
        const docsCache = {};

        async function loadMarkdown(term) {
            if (docsCache[term]) return docsCache[term];
            try {
                const response = await fetch(`/api/docs/${term}`);
                if (!response.ok) throw new Error('Not found');
                const text = await response.text();
                docsCache[term] = text;
                return text;
            } catch (e) {
                return `Contenu non disponible.`;
            }
        }

        function renderMarkdownSafe(container, markdown) {
            // Uses DOMPurify to sanitize HTML before rendering
            const html = marked.parse(markdown);
            const sanitized = DOMPurify.sanitize(html);
            container.innerHTML = sanitized;
        }

        function showDocs() {
            document.body.classList.add('docs-visible');
            docsPage.classList.add('visible');
            history.pushState({ page: 'docs' }, '', '/docs');
            document.title = 'Documentation - Travel Order Resolver';
            window.scrollTo(0, 0);
        }

        function hideDocs() {
            document.body.classList.remove('docs-visible');
            docsPage.classList.remove('visible');
            history.pushState({ page: 'home' }, '', '/');
            document.title = 'Travel Order Resolver';
            setTimeout(() => sentenceInput.focus(), 100);
        }

        function initDocs() {
            docsBtn.addEventListener('click', (e) => {
                e.preventDefault();
                showDocs();
            });

            backBtn.addEventListener('click', () => {
                hideDocs();
            });

            termItems.forEach(item => {
                item.addEventListener('click', async () => {
                    const term = item.dataset.term;
                    const content = document.getElementById(term);
                    const isActive = item.classList.contains('active');

                    termItems.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.term-content').forEach(c => c.classList.remove('visible'));

                    if (!isActive) {
                        item.classList.add('active');
                        content.classList.add('visible');

                        if (!content.dataset.loaded) {
                            content.textContent = 'Chargement...';
                            const markdown = await loadMarkdown(term);
                            renderMarkdownSafe(content, markdown);
                            content.dataset.loaded = 'true';
                        }
                    }
                });
            });

            window.addEventListener('popstate', (e) => {
                if (e.state && e.state.page === 'docs') {
                    document.body.classList.add('docs-visible');
                    docsPage.classList.add('visible');
                    document.title = 'Documentation - Travel Order Resolver';
                } else {
                    document.body.classList.remove('docs-visible');
                    docsPage.classList.remove('visible');
                    document.title = 'Travel Order Resolver';
                }
            });

            if (window.location.pathname === '/docs') {
                showDocs();
            }
        }

        // Initialize
        function init() {
            tabs.forEach(tab => tab.addEventListener('click', handleTabClick));
            sentenceInput.addEventListener('keydown', handleInputKeydown);
            sentenceInput.addEventListener('keyup', handleInputKeyup);

            if (checkVoiceSupport()) {
                micBtn.addEventListener('click', toggleRecording);
                initWhisper().catch(err => {
                    console.error('Failed to load Whisper:', err);
                });
            }

            setTimeout(updateSlider, 0);
            window.addEventListener('resize', updateSlider);
            window.addEventListener('blur', handleWindowBlur);

            document.addEventListener('mousedown', (e) => {
                if (document.body.classList.contains('docs-visible')) return;
                if (e.target !== sentenceInput) {
                    e.preventDefault();
                    keepFocusOnInput();
                }
            });
            sentenceInput.addEventListener('blur', () => {
                if (!document.body.classList.contains('docs-visible')) {
                    keepFocusOnInput();
                }
            });

            initDocs();

            if (window.location.pathname !== '/docs') {
                sentenceInput.focus();

                const params = getQueryParams();
                if (params.sentence) {
                    sentenceInput.value = params.sentence;

                    const modelTab = document.querySelector(`.tab[data-model="${params.model}"]`);
                    if (modelTab && !modelTab.disabled) {
                        tabs.forEach(t => t.classList.remove('active'));
                        modelTab.classList.add('active');
                        state.currentModel = params.model;
                        setTimeout(updateSlider, 0);
                    }

                    state.currentSentence = params.sentence;
                    runSearch(state.currentModel);
                } else {
                    resultsArea.innerHTML = '';
                    document.body.classList.add('centered');
                }
            }
        }

        // Start
        init();
    </script>
</body>
</html>
